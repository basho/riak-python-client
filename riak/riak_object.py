"""
Copyright 2010 Rusty Klophaus <rusty@basho.com>
Copyright 2010 Justin Sheehy <justin@basho.com>
Copyright 2009 Jay Baird <jay@mochimedia.com>

This file is provided to you under the Apache License,
Version 2.0 (the "License"); you may not use this file
except in compliance with the License.  You may obtain
a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
"""
import copy
from riak.metadata import (
    MD_CTYPE,
    MD_INDEX,
    MD_LINKS,
    MD_USERMETA)
from riak import RiakError
from riak.util import deprecated


class RiakObject(object):
    """
    The RiakObject holds meta information about a Riak object, plus the
    object's data.
    """
    def __init__(self, client, bucket, key=None):
        """
        Construct a new RiakObject.

        :param client: A RiakClient object.
        :type client: :class:`RiakClient <riak.client.RiakClient>`
        :param bucket: A RiakBucket object.
        :type bucket: :class:`RiakBucket <riak.bucket.RiakBucket>`
        :param key: An optional key. If not specified, then the key
         is generated by the server when :func:`store` is called.
        :type key: string
        """
        try:
            if isinstance(key, basestring):
                key = key.encode('ascii')
        except UnicodeError:
            raise TypeError('Unicode keys are not supported.')

        self.client = client
        self.bucket = bucket
        self.key = key
        self._data = None
        self._encoded_data = None
        self.vclock = None
        self.metadata = {MD_USERMETA: {}, MD_INDEX: []}
        self.links = []
        self.siblings = []
        self.exists = False

    def __hash__(self):
        return hash((self.key, self.bucket, self.vclock))

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return hash(self) == hash(other)
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return hash(self) != hash(other)
        else:
            return True

    def _get_data(self):
        if self._encoded_data is not None and self._data is None:
            self._data = self._deserialize(self._encoded_data)
            self._encoded_data = None
        return self._data

    def _set_data(self, value):
        self._encoded_data = None
        self._data = value

    data = property(_get_data, _set_data, doc="""
        The data stored in this object, as Python objects. For the raw
        data, use the `encoded_data` property. If unset, accessing
        this property will result in decoding the `encoded_data`
        property into Python values. The decoding is dependent on the
        `content_type` property and the bucket's registered decoders.
        :type mixed """)

    def get_encoded_data(self):
        deprecated("`get_encoded_data` is deprecated, use the `encoded_data`"
                   " property")
        return self.encoded_data

    def set_encoded_data(self, value):
        deprecated("`set_encoded_data` is deprecated, use the `encoded_data`"
                   " property")
        self.encoded_data = value

    def _get_encoded_data(self):
        if self._data is not None and self._encoded_data is None:
            self._encoded_data = self._serialize(self._data)
            self._data = None
        return self._encoded_data

    def _set_encoded_data(self, value):
        self._data = None
        self._encoded_data = value

    encoded_data = property(_get_encoded_data, _set_encoded_data, doc="""
        The raw data stored in this object, essentially the encoded
        form of the `data` property. If unset, accessing this property
        will result in encoding the `data` property into a string. The
        encoding is dependent on the `content_type` property and the
        bucket's registered encoders.
        :type basestring""")

    def _serialize(self, value):
        encoder = self.bucket.get_encoder(self.content_type)
        if encoder:
            return encoder(value)
        elif isinstance(value, basestring):
            return value.encode()
        else:
            raise TypeError('No encoder for non-string data '
                            'with content type "{0}"'.
                            format(self.content_type))

    def _deserialize(self, value):
        decoder = self.bucket.get_decoder(self.content_type)
        if decoder:
            return decoder(value)
        else:
            raise TypeError('No decoder for content type "{0}"'.
                            format(self.content_type))

    def _get_usermeta(self):
        if MD_USERMETA in self.metadata:
            return self.metadata[MD_USERMETA]
        else:
            return {}

    def _set_usermeta(self, usermeta):
        self.metadata[MD_USERMETA] = usermeta
        return self

    usermeta = property(_get_usermeta, _set_usermeta,
                        doc="""
        The custom user metadata on this object. This doesn't
        include things like content type and links, but only
        user-defined meta attributes stored with the Riak object.

        :param userdata: The user metadata to store.
        :type userdata: dict
        """)

    def add_index(self, field, value):
        """
        Tag this object with the specified field/value pair for
        indexing.

        :param field: The index field.
        :type field: string
        :param value: The index value.
        :type value: string or integer
        :rtype: RiakObject
        """
        if field[-4:] not in ("_bin", "_int"):
            raise RiakError("Riak 2i fields must end with either '_bin'"
                            " or '_int'.")

        rie = (field, value)
        if not rie in self.metadata[MD_INDEX]:
            self.metadata[MD_INDEX].append(rie)

        return self

    def remove_index(self, field=None, value=None):
        """
        Remove the specified field/value pair as an index on this
        object.

        :param field: The index field.
        :type field: string
        :param value: The index value.
        :type value: string or integer
        :rtype: RiakObject
        """
        if not field and not value:
            ries = self.metadata[MD_INDEX][:]
        elif field and not value:
            ries = [x for x in self.metadata[MD_INDEX]
                    if x[0] == field]
        elif field and value:
            ries = [(field, value)]
        else:
            raise RiakError("Cannot pass value without a field"
                            " name while removing index")

        # This removes the index entries that's in the ries list.
        # Done because this is preferred over metadata[MD_INDEX].remove(rie)
        self.metadata[MD_INDEX] = [rie for rie in self.metadata[MD_INDEX]
                                   if rie not in ries]
        return self

    remove_indexes = remove_index

    def set_indexes(self, indexes):
        """
        Replaces all indexes on a Riak object. Currently supports an
        iterable of 2 item tuples, (field, value).

        :param indexes: iterable of 2 item tuples consisting the field
                        and value. Both the field and the value must
                        be a string.
        :rtype: RiakObject
        """
        # makes a copy and does type conversion
        # this seems rather slow
        self.metadata[MD_INDEX] = indexes[:]
        return self

    def get_indexes(self, field=None):
        """
        Get a list of the index entries for this object. If a field is
        provided, returns a list

        :param field: The index field.
        :type field: string or None
        :rtype: (array of 2 element tuples with field, value) or
                (array of string or integer)
        """
        if field is None:
            return self.metadata[MD_INDEX]
        else:
            return [v for f, v in self.metadata[MD_INDEX] if f == field]

    def _get_content_type(self):
        try:
            return self.metadata[MD_CTYPE]
        except KeyError:
            if self._data:
                return "application/json"
            else:
                return "application/octet-stream"

    def _set_content_type(self, content_type):
        """
        Set the content type of this object.

        :param content_type: The new content type.
        :type content_type: string
        :rtype: self
        """
        self.metadata[MD_CTYPE] = content_type
        return self

    content_type = property(_get_content_type, _set_content_type,
                            doc="""
        The content type of this object. This is either
        ``application/json``, or the provided content type if the
        object was created via :func:`RiakBucket.new_binary
        <riak.bucket.RiakBucket.new_binary>`.

        :rtype: string """)

    def set_links(self, links, all_link=False):
        """
        Replaces all links to a RiakObject

        :param links: An iterable of 2-item tuples, consisting of
            (RiakObject, tag). This could also be an iterable of just
            a RiakObject, instead of the tuple, then a tag of None
            would be used. Lastly, it could also be an iterable of
            3 item tuples with the format of (bucket, key, tag), where tag
            could be None

        :param all_link: A boolean indicates if links are all 3 item tuples
            objects This speeds up the operation so there is no iterating
            through and parsing elements.
        """
        if all_link:
            self.metadata[MD_LINKS] = links
            return self

        new_links = []
        for item in links:
            if isinstance(item, tuple):
                if len(item) == 3:
                    link = item
                elif len(item) == 2:
                    link = (item[0].bucket.name, item[0].key, item[1])
            elif isinstance(item, RiakObject):
                link = (item.bucket.name, item.key, None)

            new_links.append(link)

        self.metadata[MD_LINKS] = new_links
        return self

    def add_link(self, obj, tag=None):
        """
        Add a link to a RiakObject.

        :param obj: Either a RiakObject or 3 item link tuple consisting
            of (bucket, key, tag).
        :type obj: mixed
        :param tag: Optional link tag. Defaults to bucket name. It is ignored
            if ``obj`` is a 3 item link tuple.
        :type tag: string
        :rtype: RiakObject
        """
        if isinstance(obj, tuple):
            newlink = obj
        else:
            newlink = (obj.bucket.name, obj.key, tag)

        self.remove_link(newlink)
        links = self.metadata[MD_LINKS]
        links.append(newlink)
        return self

    def remove_link(self, obj, tag=None):
        """
        Remove a link to a RiakObject.

        :param obj: Either a RiakObject or 3 item link tuple consisting
            of (bucket, key, tag).
        :type obj: mixed
        :param tag: Optional link tag. Defaults to bucket name. It is ignored
            if ``obj`` is a 3 item link tuple.
        :type tag: string
        :rtype: RiakObject
        """
        if isinstance(obj, tuple):
            oldlink = obj
        else:
            oldlink = (obj.bucket.name, obj.key, tag)

        a = []
        links = self.metadata.get(MD_LINKS, [])
        for link in links:
            if not link == oldlink:
                a.append(link)

        self.metadata[MD_LINKS] = a
        return self

    def get_links(self):
        """
        Return an array of 3 item link tuples.

        :rtype: list
        """
        return self.metadata.get(MD_LINKS, [])

    def store(self, w=None, dw=None, pw=None, return_body=True,
              if_none_match=False):
        """
        Store the object in Riak. When this operation completes, the
        object could contain new metadata and possibly new data if Riak
        contains a newer version of the object according to the object's
        vector clock.

        :param w: W-value, wait for this many partitions to respond
         before returning to client.
        :type w: integer
        :param dw: DW-value, wait for this many partitions to
         confirm the write before returning to client.
        :type dw: integer

        :param pw: PW-value, require this many primary partitions to
                   be available before performing the put
        :type pw: integer
        :param return_body: if the newly stored object should be
                            retrieved
        :type return_body: bool
        :param if_none_match: Should the object be stored only if
                              there is no key previously defined
        :type if_none_match: bool
        :rtype: RiakObject """
        if (self.siblings and not self._data
                and not self._encoded_data and not self.vclock):
            raise RiakError("Attempting to store an invalid object,"
                            "store one of the siblings instead")

        if self.key is None:
            key, vclock, metadata = self.client.put_new(
                self, w=w, dw=dw, pw=pw,
                return_body=return_body,
                if_none_match=if_none_match)
            self.exists = True
            self.key = key
            self.vclock = vclock
            self.metadata = metadata
        else:
            result = self.client.put(self, w=w, dw=dw, pw=pw,
                                     return_body=return_body,
                                     if_none_match=if_none_match)
            if result is not None and result != ('', []):
                self._populate(result)

        return self

    def reload(self, r=None, pr=None, vtag=None):
        """
        Reload the object from Riak. When this operation completes, the
        object could contain new metadata and a new value, if the object
        was updated in Riak since it was last retrieved.

        :param r: R-Value, wait for this many partitions to respond
         before returning to client.
        :type r: integer
        :rtype: RiakObject
        """

        result = self.client.get(self, r=r, pr=pr, vtag=vtag)

        self.clear()
        if result is not None and result != ('', []):
            self._populate(result)

        return self

    def delete(self, rw=None, r=None, w=None, dw=None, pr=None, pw=None):
        """
        Delete this object from Riak.

        :param rw: RW-value. Wait until this many partitions have
            deleted the object before responding. (deprecated in Riak
            1.0+, use R/W/DW)
        :type rw: integer
        :param r: R-value, wait for this many partitions to read object
         before performing the put
        :type r: integer
        :param w: W-value, wait for this many partitions to respond
         before returning to client.
        :type w: integer
        :param dw: DW-value, wait for this many partitions to
         confirm the write before returning to client.
        :type dw: integer
        :param pr: PR-value, require this many primary partitions to
                   be available before performing the read that
                   precedes the put
        :type pr: integer
        :param pw: PW-value, require this many primary partitions to
                   be available before performing the put
        :type pw: integer
        :rtype: RiakObject
        """

        self.client.delete(self, rw=rw, r=r, w=w, dw=dw, pr=pr, pw=pw)
        self.clear()
        return self

    def clear(self):
        """
        Reset this object.

        :rtype: RiakObject
        """
        self.headers = []
        self.links = []
        self.data = None
        self.exists = False
        self.siblings = []
        return self

    def _populate(self, result):
        """
        Populate the object based on the return from get.

        If None returned, then object is not found
        If a tuple of vclock, contents then one or more
        whole revisions of the key were found
        If a list of vtags is returned there are multiple
        sibling that need to be retrieved with get.
        """
        self.clear()
        if result is None:
            return self
        elif type(result) is list:
            self._set_siblings(result)
        elif type(result) is tuple:
            (vclock, contents) = result
            self.vclock = vclock
            if len(contents) > 0:
                (metadata, data) = contents.pop(0)
                self.exists = True
                if not MD_INDEX in metadata:
                    metadata[MD_INDEX] = []
                self.metadata = metadata
                self._encoded_data = data
                # Create objects for all siblings
                siblings = [self]
                for (metadata, data) in contents:
                    sibling = copy.copy(self)
                    sibling.metadata = metadata
                    sibling.encoded_data = data
                    siblings.append(sibling)
                for sibling in siblings:
                    sibling._set_siblings(siblings)
        else:
            raise RiakError("do not know how to handle type %s" % type(result))

    def get_sibling(self, i, r=None, pr=None):
        """
        Retrieve a sibling by sibling number.

        :param i: Sibling number.
        :type i: integer
        :param r: R-Value. Wait until this many partitions
            have responded before returning to client.
        :type r: integer
        :rtype: RiakObject.
        """
        if isinstance(self.siblings[i], RiakObject):
            return self.siblings[i]
        else:
            # Run the request...
            vtag = self.siblings[i]
            obj = RiakObject(self.client, self.bucket, self.key)
            obj.reload(r=r, pr=pr, vtag=vtag)

            # And make sure it knows who its siblings are
            self.siblings[i] = obj
            obj._set_siblings(self.siblings)
            return obj

    def _set_siblings(self, siblings):
        """
        Set the array of siblings - used internally

        .. warning::

            Make sure this object is at index 0 so get_siblings(0)
            always returns the current object
        """
        try:
            i = siblings.index(self)
            if i != 0:
                siblings.pop(i)
                siblings.insert(0, self)
        except ValueError:
            pass

        if len(siblings) > 1:
            self.siblings = siblings
        else:
            self.siblings = []

    def add(self, *args):
        """
        Start assembling a Map/Reduce operation.
        A shortcut for :func:`RiakMapReduce.add`.

        :rtype: RiakMapReduce
        """
        mr = RiakMapReduce(self.client)
        mr.add(self.bucket.name, self.key)
        return mr.add(*args)

    def link(self, *args):
        """
        Start assembling a Map/Reduce operation.
        A shortcut for :func:`RiakMapReduce.link`.

        :rtype: RiakMapReduce
        """
        mr = RiakMapReduce(self.client)
        mr.add(self.bucket.name, self.key)
        return mr.link(*args)

    def map(self, *args):
        """
        Start assembling a Map/Reduce operation.
        A shortcut for :func:`RiakMapReduce.map`.

        :rtype: RiakMapReduce
        """
        mr = RiakMapReduce(self.client)
        mr.add(self.bucket.name, self.key)
        return mr.map(*args)

    def reduce(self, *args):
        """
        Start assembling a Map/Reduce operation.
        A shortcut for :func:`RiakMapReduce.reduce`.

        :rtype: RiakMapReduce
        """
        mr = RiakMapReduce(self.client)
        mr.add(self.bucket.name, self.key)
        return mr.reduce(*args)

from riak.mapreduce import RiakMapReduce
